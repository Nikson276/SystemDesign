
# Встреча №1 - Ревью

## Нужно добавить и продумать

- [x] Сервис `Subscription service` (для реализации SAGA Choreography на сценарии подписки)
- [x] Сервис нотификации `Notification Service` на почту для подтверждения регистрации, отправки писем о покупке подписки, отмене подписки.
- [x] Сервис `Auth Service` для авторизации, аутентификации и управления токенами
- [x] Внешний OAuth Provider (Google/VK/Yandex...)
- [x] Для сервиса Каталогов подумать про CQRS (Запись с индексацией отдельно, поиск отдельно. Обновление Read Model делается через event-driven подход)
- [x] Сервис CDP для Эластика и Постгресс чтобы их засинкать
- [x] Выбор CDN (сервис)
- [x] Собственный CDN вместо Яндекса чтобы экономить деньги на услуге (выбирать сервер, выбирать оптимальный по расстоянию и загрузке)
- [x] Доставка контента на CDN
- [x] Сервис `Events Statistics` для сбора статистики прослушивания клиента (отдельный сервис, в отдельном месте и сервере, хранилище)

### Сервисы `Subscription service`, `Notification Service`, `Auth Service`

> -> на развитие, Переписываем на Orchestration и делаем SubscriptionWorkflowManager

**SAGA Choreography на сценарие подписки**

- `Payment Service` → событие `PaymentCompleted` (или `PaymentFailed`)
- `Subscription Service` → ловит `PaymentCompleted`, обновляет базу, публикует `SubscriptionActivated` (или `SubscriptionFailed`).
- `Notification Service` → ловит `SubscriptionActivated`, шлет уведомление.
- `User Service` публикует `UserUpdated` в Kafka, с полем `is_premium`=true.
- `Auth Service` подписан на `UserUpdated` и, если `is_premium` изменился, пересоздаёт refresh-токен или меняет payload JWT в Redis.

**Компенсация (если упал любой шаг):**

- `PaymentFailed` → просто отмена процесса.
- Если упал `Subscription Service` — генерируется событие `SubscriptionFailed`, `Payment Service` ловит его и делает возврат.

#### [Кейс: Оформляем подписку](./06_runtime_view.md#сценарий-2-пользователь-оформляет-премиум-подписку)

### CDP для Эластика и Постгрес

> CDP нужен, если мы хотим обновлять Read-модель в Elastic при изменении данных не только из Write-модели, а ещё и при любом изменении Postgres (например, админ правит метаданные напрямую в админке).
>
> CQRS требует, чтобы Read-модель всегда была пересчитана из Write-модели, а не частично обновлена.

> Два источника событий:
> - События от Write-модели через Kafka (TrackPublished, TrackUpdated).
> - CDC события от Debezium при прямых изменениях в Postgres (например, через админку).

#### [Кейс: Загрузка треков в Админке](./06_runtime_view.md#сценарий-3-автор-загружает-новый-трек-через-админку)

## Почитать изучить

- [x] Почитать про OAuth20 - например через гугл, как работает вся цепочка, как получать инфо для профиля и т д
- [x] CQRS (изучить примеры и какие правила)
- [x] Теорема САР для Постгрес и для Эластик
  - [x] Postgres только Мастер=ACID, если реплики то из CAP по умолчанию = CP (жёсткая согласованность важнее, чем доступность при Partition)
  - [x] Elasticsearch — распределённая система по умолчанию (кластер из шардов и реплик), т.е. = AP (в момент Partition жертвует строгой согласованностью ради доступности). Согласованность eventual consistency.
- [x] Про CDP - что это и как реализовать для Эластик и\или Постгрес
- [x] Выбор CDN сервера, на бэкенде или клиенте? мб новый сервер?
- [x] Почитать про Пинг и как его использовать в поиске для анализа загрузки сервера
- [x] Как доставлять контент на CDN (сначала они пустые)
- [x] Рекурентный платеж
- [x] Паттерн САГА спрятан (Изучить на этом примере и другом)

## * На подумать и добавить или нет в архитектуру

- [ ] Clickhouse для большого объема статистики данных стукрутрированных (нужно протестить и проверить что это реально лучше Postgres)
- [ ] Подобные задачи как рекомендации, генерации ленты и т д это дорогие операции их надо отложенно выполнять, и выдавать резульатат. КАК?

## Конспект

### OAuth2.0

> OAuth 2.0 - протокол, стандарт (схема) авторизации в индустрии, обеспечивающий предоставление третьей стороне ограниченного доступа к защищённым ресурсам пользователя без передачи ей (третьей стороне) логина и пароля. Он только про авторизацию и обмен токенами.
> 
> А OpenID Connect (OIDC) — это надстройка над OAuth 2.0, которая добавляет стандартный способ получить данные профиля пользователя из внешней системы.
> Это открытый стандарт авторизации, который предоставляет способ для аутентификации и авторизации пользователей в веб-приложении или API. Он основан на протоколе OAuth 2.0 и расширяет его, добавляя слой аутентификации с помощью идентификационных токенов.

### CQRS

> **Command Query Responsibility Segregation (CQRS)** — это паттерн проектирования, который разделяет операции чтения и записи в базу данных.
>
> - **Command** — это операция, которая изменяет состояние системы.  
    Пример: _"загрузить новый трек"_, _"обновить метаданные"_, _"удалить трек"_.
> - **Query** — это операция, которая читает данные, **не изменяя их**.  
    Пример: _"получить список треков по жанру"_, _"найти треки по названию"_.

#### Когда CQRS НЕ нужен

- Если система маленькая и БД справляется с чтением и записью в одной модели.
- Если данные легко обрабатывать одинаково для чтения и записи.
- Если задержка между записью и доступностью для чтения должна быть **нулевой** (CQRS часто асинхронен).

> Write Model = Postgres + очередь на обработку и индексирование ES.
>
> Read Model = ElasticSearch + Redis для горячих выборок.

> Write API и Query API могут быть отдельными сервисами/деплойментами.
> ES можно масштабировать независимо от Postgres.

### Теорема CAP, ACID, BASE

| Система           | CAP-профиль | Философия | Что означает для работы                                                                                               |
| ----------------- | ----------- | --------- | --------------------------------------------------------------------------------------------------------------------- |
| **Postgres**      | **CP**      | **ACID**  | Жёсткая транзакционная модель. Согласованность ценой потери доступности записи при развале кластера.                  |
| **ElasticSearch** | **AP**      | **BASE**  | Всегда доступен для поиска, но новые данные могут появляться с задержкой. Реплики могут быть временно не согласованы. |

### CDC / CDP

Change Data Capture / Change Data Processing — это паттерн, который позволяет отслеживать изменения данных в источнике (insert/update/delete в Postgres) и передавать эти изменения в другие системы в реальном времени или почти в реальном времени

> **Пример использования:**
>
> - Админ загружает трек → Write модель (Postgres) получает новую запись.
> - Система CDP замечает, что в таблице tracks добавились новые данные.
> - Событие отправляется в процессор (Kafka consumer).
> - Процессор обновляет Read модель — ElasticSearch индекс.
> - Пользователь через поиск уже может найти этот трек.

### CDN

**CDN (Content Delivery Network)** — сеть серверов, расположенных в разных географических точках, которые хранят и доставляют статичный/квази-статичный контент (файлы, изображения, видео, аудио) пользователю **с максимально близкой точки**.

**POP (Points Of Presence)** — Точки присутствия. По сути, это промежуточный узел, который хранит закэшированные копии файлов — изображений, видео, скриптов и страниц — и выдаёт их ближе к месту запроса.

#### Как контент попадает в CDN?

Есть два основных подхода:

> Вариант A: **Pull-based CDN («ленивая» загрузка)**
>
> ✅ Плюсы: проще настроить, не нужно управлять пушем.  
> ❌ Минусы: **первый запрос медленный**, риск (тысячи запросов одновременно → все идут в S3).
>
> Подходит для MVP, особенно если у тебя **длинный хвост контента** (много редко слушаемых треков).

---

> Вариант B: **Push-based CDN («активная» загрузка)**
>
> ✅ Плюсы: **гарантировано быстрый первый запрос**, контроль над прогревом.  
> ❌ Минусы: сложнее, дороже (платишь за storage в CDN), нужно управлять циклом жизни (инвалидация при обновлении).
>
> Подходит для **популярного контента** (новинки, хиты), но избыточен для редких треков.

#### Механизм поиска оптимального POP

- `Ping` — это утилита и протокол (ICMP), которые позволяют измерить **время круговой задержки (Round-Trip Time, RTT)** между вашим компьютером и целевым сервером. **Низкий пинг (1-30 мс)** / **Высокий пинг (100+ мс)**
- **джиттер** (разброс значений пинга во времени)

Ping используется в комбинации с другими метриками:

1. **Ping + Скорость загрузки:** После выбора сервера по низкому пингу, клиент может сделать тест на скачивание маленького файла (например, `test.chunk` размером 1 МБ) и измерить реальную пропускную способность.

2. **Метрики с сервера:** Серверы сами сообщают о своей загрузке (CPU, RAM, I/O, количество подключений) в центральную систему управления. Алгоритм выбора может выглядеть так:

    - Отфильтровать все серверы с загрузкой > 80%.
    - Из оставшихся выбрать 3 с наименьшим пингом до пользователя.
    - Среди этих трех выбрать тот, у которого самая низкая сетевая загрузка

Активное зондирование и измерение задержки:

> **Сценарий А (Со стороны клиента):**
>
> Плеер получает список из 3-5 IP-адресов серверов-кандидатов. Затем он посылает на каждый из них серию `ping`-запросов.
> Измеряется средний RTT и джиттер. Сервер с **наименьшим и наиболее стабильным пингом** победил.

> **Сценарий Б (Со стороны сервера / "Active Probing")**.
>
> Сама инфраструктура CDN постоянно мониторит себя. Когда пользователь запрашивает контент, система уже имеет актуальную "карту здоровья" сети и может выдать лучший сервер

**Итого**

- **Ping (RTT)** — это первичный, быстрый и дешевый способ отсеить заведомо плохие варианты и найти серверы, которые _топологически_ близки к пользователю.
- **Одного пинга недостаточно** для полного анализа, так как он не отражает загрузку сервера и реальную пропускную способность.
- В реальных CDN для стриминга **ping используется в комбинации** с другими метриками: джиттер, результаты тестов на скачивание, данные о загрузке серверов и данные о здоровье сети в реальном времени.
- **Итоговый алгоритм** — это всегда компромисс между минимальной задержкой, максимальной пропускной способностью и стабильностью соединения.

### SAGA pattern

**SAGA** — это паттерн координации **распределённых транзакций** в микросервисной архитектуре.  
В ситуации, когда один бизнес-процесс затрагивает несколько сервисов (каждый со своей БД, своим состоянием), мы не можем применить классическую монолитную транзакцию `BEGIN/COMMIT/ROLLBACK`.

SAGA решает это так:

> Разбивает большую транзакцию на цепочку **локальных операций**, каждая из которых атомарна в своём сервисе, и описывает **компенсирующие действия** для отката, если что-то пошло не так.

Есть два основных подхода:

#### **Choreography (Хореография)**

Каждый сервис сам знает **кому дальше послать событие**, и слушает входящие события от других сервисов.

> **Плюсы:** просто, гибко, легко расширять.
>
> **Минусы:** сложно отслеживать полный бизнес-процесс (требуется хорошая трассировка событий).

#### **Orchestration (Оркестрация)**

Есть центральный "оркестратор" или "менеджер саги", который управляет, какой сервис выполнить следующий шаг.

> **Плюсы:** проще отлаживать процесс, легко видно всю логику.
>
> **Минусы:** оркестратор становится точкой отказа и "бутылочным горлышком".

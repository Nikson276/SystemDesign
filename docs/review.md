
# Встреча №1 - Ревью

## Нужно добавить и продумать

- [ ] Сервис `Subscription service` (для реализации SAGA Choreography на сценарие подписки) -> на развите, Переписываем на Orchestration и делаем SubscriptionWorkflowManager
- [ ] Сервис нотификации `Notification Service` на почту для подтверждения регистрации, отправки писем о покупке подписки, отмене подписки.
- [ ] Сервис `Auth Service` для авторизации, аутентификации и управления токенами
- [ ] Внешний OAuth Provider (Google/VK/Yandex...)
- [ ] Для сервиса Каталогов подумать про CQRS (Запись с индексацией отдельно, поиск отдельно. Обновление Read Model делается через event-driven подход)
- [ ] Сервис CDP для Эластика и Постгресс чтобы их засинкать
- [ ] Выбор CDN (сервис)
- [ ] Собственный CDN вместо Яндекса чтобы экономить деньги на услуге (выбирать сервер, выбирать оптимальный по расстоянию и загрузке)
- [ ] Доставка контента на CDN

### Сервис `Subscription service`

**SAGA Choreography на сценарие подписки**

- Payment Service → событие PaymentCompleted (или PaymentFailed)
- Subscription Service → ловит PaymentCompleted, обновляет базу, дергает Auth Service, публикует SubscriptionActivated.
- Notification Service → ловит SubscriptionActivated, шлет уведомление.
- Ads Service → ловит SubscriptionActivated или просто видит обновленный JWT.

Компенсация (если упал любой шаг):

- PaymentFailed → просто отмена процесса.
- Если упал Subscription Service — генерируется событие SubscriptionFailed, Payment Service ловит его и делает возврат.


## Почитать изучить

- [x] Почитать про OAuth20 - например через гугл, как работает вся цепочка, как получать инфо для профиля и т д
- [x] CQRS (изучить примеры и какие правила)
- [x] Теорема САР для Постгрес и для Эластик
  - [x] Postgres только Мастер=ACID, если реплики то из CAP по умолчанию = CP (жёсткая согласованность важнее, чем доступность при Partition)
  - [x] Elasticsearch — распределённая система по умолчанию (кластер из шардов и реплик), т.е. = AP (в момент Partition жертвует строгой согласованностью ради доступности). Согласованность eventual consistency.
- [x] Про CDP - что это и как реализовать для Эластик и\или Постгрес
- [ ] Выбор CDN сервера, на бэкенде или клиенте? мб новый сервер?
- [ ] Почитать про Пинг и как его использовать в поиске для анализа загрузки сервера
- [ ] Как доставлять контент на CDN (сначала они пустые)
- [x] Рекурентный платеж
- [x] Паттерн САГА спрятан (Изучить на этом примере и другом)

## На подумать и добавить или нет в архитектуру

- Подумать про микросервис Events для сбора статистики прослушивания клиента (отдельный сервис, в отдельном месте и сревере, хранилище)
- Clickhouse для большого объема статистики данных стукрутрированных (нужно протестить и проверить что это реально лучше Postgres)
- Подобные задачи как рекомендации, генерации ленты и т д это дорогие операции их надо отложенно выполнять, и выдавать резульатат. КАК?



## Конспект 

### CAP, ACID, BASE

| Система           | CAP-профиль | Философия | Что означает для работы                                                                                               |
| ----------------- | ----------- | --------- | --------------------------------------------------------------------------------------------------------------------- |
| **Postgres**      | **CP**      | **ACID**  | Жёсткая транзакционная модель. Согласованность ценой потери доступности записи при развале кластера.                  |
| **ElasticSearch** | **AP**      | **BASE**  | Всегда доступен для поиска, но новые данные могут появляться с задержкой. Реплики могут быть временно не согласованы. |

### CQRS

> **Command Query Responsibility Segregation (CQRS)** — это паттерн проектирования, который разделяет операции чтения и записи в базу данных.
> 
> - **Command** — это операция, которая изменяет состояние системы.  
    Пример: _"загрузить новый трек"_, _"обновить метаданные"_, _"удалить трек"_.
> - **Query** — это операция, которая читает данные, **не изменяя их**.  
    Пример: _"получить список треков по жанру"_, _"найти треки по названию"_.

> Когда CQRS не нужен
> 
> - Если система маленькая и БД справляется с чтением и записью в одной модели.
> - Если данные легко обрабатывать одинаково для чтения и записи.
> - Если задержка между записью и доступностью для чтения должна быть **нулевой** (CQRS часто асинхронен).


### CDC / CDP

Change Data Capture / Change Data Processing — это паттерн, который позволяет отслеживать изменения данных в источнике (insert/update/delete в Postgres) и передавать эти изменения в другие системы в реальном времени или почти в реальном времени

> **Пример использования:**
> 
> - Админ загружает трек → Write модель (Postgres) получает новую запись.
> - Система CDP замечает, что в таблице tracks добавились новые данные.
> - Событие отправляется в процессор (Kafka consumer).
> - Процессор обновляет Read модель — ElasticSearch индекс.
> - Пользователь через поиск уже может найти этот трек.

### CDN

**CDN (Content Delivery Network)** — сеть серверов, расположенных в разных географических точках, которые хранят и доставляют статичный/квази-статичный контент (файлы, изображения, видео, аудио) пользователю **с максимально близкой точки**.

**POP (Points Of Presence)** — Точки присутствия. По сути, это промежуточный узел, который хранит закэшированные копии файлов — изображений, видео, скриптов и страниц — и выдаёт их ближе к месту запроса.

#### Как контент попадает в CDN?

Есть два основных подхода:

> Вариант A: **Pull-based CDN («ленивая» загрузка)**
> 
> ✅ Плюсы: проще настроить, не нужно управлять пушем.  
> ❌ Минусы: **первый запрос медленный**, риск (тысячи запросов одновременно → все идут в S3).
> 
> Подходит для MVP, особенно если у тебя **длинный хвост контента** (много редко слушаемых треков).

---

> Вариант B: **Push-based CDN («активная» загрузка)**
> 
> ✅ Плюсы: **гарантировано быстрый первый запрос**, контроль над прогревом.  
> ❌ Минусы: сложнее, дороже (платишь за storage в CDN), нужно управлять циклом жизни (инвалидация при обновлении).
> 
> Подходит для **популярного контента** (новинки, хиты), но избыточен для редких треков.

#### Механизм поиска оптимального POP

- `Ping` — это утилита и протокол (ICMP), которые позволяют измерить **время круговой задержки (Round-Trip Time, RTT)** между вашим компьютером и целевым сервером. **Низкий пинг (1-30 мс)** / **Высокий пинг (100+ мс)**
- **джиттер** (разброс значений пинга во времени)

Ping используется в комбинации с другими метриками:

1. **Ping + Скорость загрузки:** После выбора сервера по низкому пингу, клиент может сделать тест на скачивание маленького файла (например, `test.chunk` размером 1 МБ) и измерить реальную пропускную способность.
    
2. **Метрики с сервера:** Серверы сами сообщают о своей загрузке (CPU, RAM, I/O, количество подключений) в центральную систему управления. Алгоритм выбора может выглядеть так:
    
    - Отфильтровать все серверы с загрузкой > 80%.
    - Из оставшихся выбрать 3 с наименьшим пингом до пользователя.
    - Среди этих трех выбрать тот, у которого самая низкая сетевая загрузка

Активное зондирование и измерение задержки:

> **Сценарий А (Со стороны клиента):** 
> 
> Плеер получает список из 3-5 IP-адресов серверов-кандидатов. Затем он посылает на каждый из них серию `ping`-запросов.
> Измеряется средний RTT и джиттер. Сервер с **наименьшим и наиболее стабильным пингом** победил.

> **Сценарий Б (Со стороны сервера / "Active Probing")**.
> 
> Сама инфраструктура CDN постоянно мониторит себя. Когда пользователь запрашивает контент, система уже имеет актуальную "карту здоровья" сети и может выдать лучший сервер

**Резюме**

- **Ping (RTT)** — это первичный, быстрый и дешевый способ отсеить заведомо плохие варианты и найти серверы, которые _топологически_ близки к пользователю.
- **Одного пинга недостаточно** для полного анализа, так как он не отражает загрузку сервера и реальную пропускную способность.
- В реальных CDN для стриминга **ping используется в комбинации** с другими метриками: джиттер, результаты тестов на скачивание, данные о загрузке серверов и данные о здоровье сети в реальном времени.
- **Итоговый алгоритм** — это всегда компромисс между минимальной задержкой, максимальной пропускной способностью и стабильностью соединения.